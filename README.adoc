= FreeBSD Audio and Jack
Florian Walpen <dev@submerge.ch>
:toc:

These notes are a mixture of guidelines, configuration details and setup
recommendations for using https://jackaudio.org/[Jack Audio Server] on
https://jackaudio.org/[FreeBSD]. Most of it is based on my experiments and
findings while doing a rewrite of the Jack driver backend for FreeBSD. I am
neither a sound engineer nor an expert on FreeBSD system internals though.


== Setup and Use Cases

Requirements vary greatly between different use cases. It makes sense to be
aware of what you want to achieve, before going into the details.

=== Playback Only

This is the simplest use case, given that there is no need to synchronize the
output with external events. Latency settings can be relaxed, longer processing
cycles and large buffers keep CPU load and system timing constraints at a
minimum. If you have to synchronize with external events, see the section
on live processing.


=== Recording

Usually recording also includes playback, to e.g. capture a guitar playing
along a previously recorded drum track. Certainly you want the timing of the
guitar track to match the drums. Still there is no need to go _low latency_,
since audio software can _compensate_ the latency while recording. But it's
essential to have _stable latency_, for multiple takes and also between
recording sessions.

[NOTE]
====

While it's technically possible to use different devices for recording and
playback, this is not recommended. It may cause problems since the devices are
not synchronized and run at a slightly different speed.

====


=== Monitoring

Obviously you want to hear your instrument playing while recording. It is
_highly preferable_ to circumvent the software stack altogether and have an
external monitoring solution in hardware. This could be a complete mixing desk
or just some direct monitoring knobs on your audio interface. Going through the
software stack will introduce _noticeable_ latency.

If you have to do monitoring through Jack, use extra low latency settings.
Maybe it helps to run Jack as a high priority process and setup the monitoring
directly as connections on the Jack server, bypassing other Jack clients
(untested).


=== Live Processing

This means use cases where low latency is crucial, like add some plugin effects
to a live performance, emulating guitar amps or playing a software synthesizer.
To be honest, I don't think FreeBSD is the right tool for this job. There is no
realtime support, no good way to run multiple user processes at high priority,
and most hardware drivers set a lower limit to the duration of processing
cycles.

Don't do this unless your sounds are very timing insensitive. Or prove me wrong.


=== Hardware

There seem to be only two drivers geared towards audio interfaces for music
creation and recording. The other pcm drivers (`man sound`) _do_ work with
Jack. But a soundblaster or internal sound card may have problems recording a
guitar or driving your studio headphones.

snd_hdspe::
RME HDSPe AIO and HDSPe RayDAT, professional PCI cards from RME.
snd_uaudio::
USB audio interfaces, most class compliant devices should be supported.

Unfortunately I never got my hands on one of those expensive RME cards.
Supposedly they would provide the lowest latency and the most channels you can
get with FreeBSD.

USB audio interfaces are more common, affordable, and come in many varieties
suitable for different setups. The `snd_uaudio` driver implements the protocol
for generic USB audio class devices, so look out for a _Class Compliant_
device.

TIP: Class Compliant devices are often marketed as being "iPad compatible".

There are limitations with USB audio devices though:

* Some are not completely Class Compliant, only tested on Windows and Mac.
* Some need USB quirks to get them running.
* High sample rates with lots of channels may not be supported.
* Hardware mixing and routing is typically not accessible in software.

In any case, `snd_uaudio` works with audio blocks of length 2ms or more, which
places a lower boundary on the latency you can achieve -- expect at least 5ms
input and 7ms output latency for Jack.



== System Settings

If your hardware is recognized correctly, it appears in the system logs as pcm
device

  # dmesg | grep pcm
  pcm0: <ATI R6xx (HDMI)> at nid 3 on hdaa0
  pcm1: <Realtek ALC262 (Analog)> at nid 21 and 24,25,26 on hdaa1
  pcm2: <Realtek ALC262 (Front Analog Headphones)> at nid 27 on hdaa1
  pcm3: <USB audio> on uaudio0

and also by device driver

  # dmesg | grep uaudio
  uaudio0 on uhub2
  uaudio0: <Roland EDIROL UA-25EX, rev 1.10/1.00, addr 2> on usbus4
  uaudio0: Play[0]: 48000 Hz, 2 ch, 24-bit S-LE PCM format, 2x2ms buffer.
  uaudio0: Record[0]: 48000 Hz, 2 ch, 24-bit S-LE PCM format, 2x2ms buffer.
  uaudio0: MIDI sequencer.
  pcm3: <USB audio> on uaudio0
  uaudio0: No HID volume keys found.

Otherwise check the
https://docs.freebsd.org/en/books/handbook/multimedia/[handbook] on how to
setup your sound card.

=== Driver Setup

Most drivers don't need any special treatment and work just fine. USB audio is
a bit different due to the variety of hardware and supported formats. Some
important settings are available at boot time (`man snd_uaudio`):

./boot/loader.conf
----
snd_uaudio_load="YES" # <1>

hw.usb.uaudio.default_channels="2" # <2>
hw.usb.uaudio.default_bits="24"
hw.usb.uaudio.default_rate="48000"

hw.usb.quirk.0="0x0a4a 0xc150 0x0000 0xffff UQ_CFG_INDEX_1" # <3>
hw.usb.quirk.1="0x0582 0x00e6 0x0000 0xffff UQ_AU_VENDOR_CLASS"
----
<1> Force loading the driver, prerequisite for other settings.
<2> Default number of channels, sample size and sample rate.
<3> Quirks to make some incompatible devices work.

If a USB device supports multiple configurations, the driver will choose the
"best" one. You can make it prefer a different channel count, sample size and
sample rate by setting the defaults here. Quirks are needed when devices don't
adhere to standards and only work with some special treatment. See `man
usb_quirk`.

=== Device Settings

These are system-wide settings to manage sound devices. Sound devices are
numbered for identification, with an unnumbered alias `/dev/dsp` which
represents the default device.

./etc/sysctl.conf
----
hw.snd.verbose=2 # <1>
hw.snd.default_auto=0 # <2>
hw.snd.default_unit=1 # <3>
----
<1> Get more info from `/dev/sndstat`, _recommended_!
<2> Automatically assign the default sound device `/dev/dsp`.
<3> Manually set the default sound device `/dev/dsp`.

See `man sound` for more details and possible values. The default sound device is
picked up by desktop environments and other software like browsers. I prefer to
set it to some internal sound card, and _not_ to my main audio interface, to
avoid conflicts.

WARNING: Order and numbering of sound devices is not fixed and may change on
reboot if new hardware is added.

=== Latency Tuning

One important latency factor is the number of samples that the device driver
processes at once. For USB devices this is set at boot time:

./boot/loader.conf
----
hw.usb.uaudio.default_channels="2"
----

I highly recommend to use the minimum value here, which is 2 milliseconds of
sample data. Apart from reducing the transfer latency, it also has another
effect. Even if Jack processes a larger block of samples per cycle, this
smoothes out the cycle times.

For non-USB devices have a look at the corresponding man page. If the driver
provides no dedicated knobs, it may be worth a try to lower the generic sound
latency tunables (`man sound`):

./etc/sysctl.conf
----
hw.snd.latency=0
hw.snd.latency_profile=0
----

These mainly affect the buffering latency, which is irrelevant to Jack. But
some device drivers adapt to these tunables and process smaller blocks of
samples at once.

Although not directly involved, timing accuracy also plays a role with latency.
Inaccurate timer wakeups contribute to buffer over- and underruns, especially
with low-latency setups. The following increases overall timing accuracy of the
system and is recommended for all use cases:

./etc/sysctl.conf
----
kern.timecounter.alloweddeviation=0
----

The only downside is more frequent system wakeups, which translates to higher
power and battery consumption on laptops.
